%Derek Lax
%1D/2D/3D Finite Volume Solver with CMFD


clear
clc
close all

%Problem Solving Specifications
dimensions = 1;
MethodGauss = 1;
MethodEigs = 0;
max_iters = 10000;
gridReductionFactor = [2 1 1];
iterationsBetweenCMFD = 5;

ng = 2;
mat = Material();
D = [1.5 0.3];
sigA = [0.05 .5];
nusigF = [[0.02 0.0]
          [0.48 0.0]];
sigS = [[0.05 0.1]
        [0.0 0.5]]; 
mat.D = D;
tot = [.2 1];
mat.nusigF = nusigF;
mat.sigT = tot;
mat.sigA = sigA;
mat.sigS = sigS;
mat.nusigF = nusigF;
mat2 = Material();
D = [1.0 .1];
sigA = [0.5 0];
nusigF = [[0 0.0]
          [0 0.0]];
sigS = [[0.5 0.1]
        [0.01 5]]; 
tot = [1.1 5.01];
mat2.D = D;
mat2.nusigF = nusigF;
mat2.sigT = tot;
mat2.sigA = sigA;
mat2.sigS = sigS;
mat2.nusigF = nusigF;

x_len = 6; y_len = 1; z_len = 1;
mesh = Mesh(x_len,y_len,z_len,ng);
mesh = mesh.setNumMats(1);
mesh.mats = [mat];
mesh = mesh.setAllMat(1,mat);
%for i = 1:x_len
%    mesh = mesh.setMatAtLoc(i,1,1,2,mat2);
%end
mesh = mesh.setEqualDist(1,200,1,1);
mesh = mesh.setBC(0, 1, 1);%set BC, vacuum, reflective, reflective
total_mesh = mesh.x * mesh.y * mesh.z * mesh.g;

[M mesh] = BuildLossMatrix(mesh, 1, false, 0);
F = BuildProductionMatrix(mesh, 1);

%Initial Guess:
format long
k = 1;
kold = .1;
convergence = 10^-6;
phiold = ones(total_mesh,1);
if MethodGauss == 1
    for iters = 1:max_iters

        if (abs(k-kold) < convergence)
            break;
        end
        kold = k;
        b = F*phiold/kold;
        phi = M\b;
        k = kold * sum(phi)/sum(phiold);
         phi = phi / sum(sum(phi));
        phiold = phi;
        flux = reshape(phi,ng,numel(phi)/ng,1,1);
        for i1 = 1:x_len
            for j1 = 1:y_len
                for k1 = 1:z_len
                    for g1 = 1:ng
                        for surf = 1:6
                            %check for boundary
                            xyz = round((surf / 2)); %1=x;2=y;3=z
                            %%determine left or right surface
                            side = -2 * mod(surf,2) + 1; % -1=left, 1=right
                            %%determine neighbor index
                            %if doesn't exist (boundary), returns -1
                            %if doesn't exist (boundary), returns -1
                            if (xyz == 1)
                                i2 = i1 + side;
                                j2 = j1;
                                k2 = k1;
                            elseif (xyz == 2)
                                i2 = i1;
                                j2 = j1 + side;
                                k2 = k1;
                            else %(xyz == 3) 
                                i2 = i1;
                                j2 = j1;
                                k2 = k1 + side;		        	
                            end
                            neigh = checkBoundary(i1,j1,k1,x_len,y_len,z_len,xyz,side);
                            if (neigh == 1)
                            %not boundary
                                %calculate current for each boundary
                                mesh.Jsurf(i1,j1,k1,g1,surf) = -mesh.dtilde(i1,j1,k1,g1,surf) * ...
                                    (flux(g1,i1,j1,k1) - flux(g1,i2,j2,k2));
                            else
                            %boundary
                                mesh.Jsurf(i1,j1,k1,g1,surf) = -mesh.dtilde(i1,j1,k1,g1,surf) * ...
                                    flux(g1,i1,j1,k1);
                            end
                        end
                    end
                end
            end
        end

    end
elseif MethodEigs == 1
    k = eigs(M\F);
end


ktrue = k;
disp k;
disp (k);
disp('iters');
disp(iters);

if (MethodGauss && dimensions == 1)
    flux = reshape(phi,ng,numel(phi)/ng,1,1);
    plotflux = reshape(phi,ng,numel(phi)/ng);
    plot(mesh.X,plotflux(1,:));
    hold on
    if (ng == 2) 
        plot(mesh.X,plotflux(2,:),'r');
    end
    xlabel('x (cm)')
    ylabel('Normalized Flux');
    legend('Group 1', 'Group 2');
    title('Reactor Flux Profile');
end

%save flux
mesh.phi = flux;




%%Check the neutron balance in the cell

% volume = prod(mesh.dxyz(2,1,1));
% phi1 = mesh.phi(1,1,1,1);
% phi2 = mesh.phi(1,2,1,1);
% sigT = mesh.sigT(2,1,1,1);
% sigS1 = mesh.sigS(2,1,1,1,1);
% sigS2 = mesh.sigS(2,1,1,2,1);
% sigF1 = mesh.nusigF(2,1,1,1,1);
% sigF2 = mesh.nusigF(2,1,1,1,2);
% current = mesh.Jsurf(2,1,1,1,1) + mesh.Jsurf(2,1,1,1,2)
% loss = sigT*phi1*volume + current
% gain = sigS1*phi1*volume + sigS2*phi2*volume + sigF1*phi1*volume + sigF2*phi2*volume


%%Done Checking



%Make coarse mesh from fine mesh
coarse = Mesh.fineToCoarse(mesh,gridReductionFactor);
reference = coarse.phi;
figure;
plot(coarse.phi(:,1,1,1));

 [M2 coarse] = BuildLossMatrix(coarse, 1, true, mesh);
 F2 = BuildProductionMatrix(coarse, 1);
 
 total_mesh = coarse.x * coarse.y * coarse.z * coarse.g;
 %Initial Guess:
 format long
 k = 1;
 kold = .1;
 convergence = 10^-8;
 phiold = ones(total_mesh,1);
 if MethodGauss == 1
    for iters = 1:max_iters

        if (abs(k2-kold2) < convergence)
            break;
        end
        kold2 = k2;
        b2 = F2*phiold2/kold2;
        phi2 = M2\b2;
        k2 = kold2 * sum(phi2)/sum(phiold2);
        phi2 = phi / sum(sum(phi));
        phiold = phi;
        flux = reshape(phi,ng,numel(phi)/ng,1,1);
        
     end
 elseif MethodEigs == 1
     k = eigs(M2\F2);
 end
 disp k;
 disp (k);
 
 if (MethodGauss && dimensions == 1)
     flux = reshape(phi,ng,numel(phi)/ng);
     figure;
     plot(coarse.X,flux(1,:));
     hold on
     if (ng == 2) 
         plot(coarse.X,flux(2,:),'r');
     end
     xlabel('x (cm)')
     ylabel('Normalized Flux');
     legend('Group 1', 'Group 2');
     title('Reactor Flux Profile');
 end
 
 %for i=1:x_len/gridReductionFactor(1)
 %disp(['Left Surface, Coarse Cell ' num2str(i)]);
 %disp(coarse.Jsurf(i,1,1,1,1));
 %disp(mesh.Jsurf(1+(i-1)*gridReductionFactor(1),1,1,1,1));
% 
% disp('Total Reaction Rate, Coarse Cell');
% disp(coarse.DXYZ(1,1,1,1) *coarse.Phi(1,1,1,1) * coarse.sigT(1,1,1,1));
% disp(mesh.DXYZ(1,1,1,1) *mesh.Phi(1,1,1,1) * mesh.sigT(1,1,1,1)+mesh.DXYZ(2,1,1,1) *mesh.Phi(1,2,1,1) * mesh.sigT(2,1,1,1));
% 
% disp('Flux, Coarse Cell');
% disp(coarse.Phi(1,1,1,1));
% disp(mesh.Phi(1,1,1,1) + mesh.Phi(1,2,1,1));
% 
% disp(['Right Surface, Coarse Cell ' num2str(i)]);
% disp(coarse.Jsurf(i,1,1,1,2));
% disp(mesh.Jsurf(i*gridReductionFactor(1),1,1,1,2));
% 
% end
 
 
close all
 